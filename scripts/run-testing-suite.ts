#!/usr/bin/env node

/**
 * Comprehensive Testing Suite Runner for Medical Triage System
 * Auto-generated by TestingOrchestrator
 */

import { TestingOrchestrator } from '@/lib/testing/TestingOrchestrator';
import { AnthropicProvider } from '@/lib/adapters/llm/AnthropicProvider';
import { ConfigManager } from '@/lib/config';
import { logger } from '@/lib/logger';

interface TestSuiteOptions {
  scope: 'agents' | 'adapters' | 'orchestrator' | 'full';
  parallel: boolean;
  generateData: boolean;
  runCoverage: boolean;
  medicalGrade: boolean;
  costOptimization: boolean;
  maxConcurrency?: number;
}

class MedicalTriageTestRunner {
  private orchestrator: TestingOrchestrator;
  private config: any;

  constructor() {
    this.config = ConfigManager.getConfig();
    
    // Initialize LLM provider for test generation
    const provider = new AnthropicProvider(
      this.config.anthropicApiKey,
      this.config.anthropicModel,
      true, // Enable caching for cost optimization
      this.config.anthropicSonnetModel,
      true, // Enable smart routing
      {
        enableBatching: true,
        batchSize: 50,
        maxWaitTimeMs: 10000,
        batchingThreshold: 5
      }
    );

    this.orchestrator = new TestingOrchestrator(provider);
  }

  async runFullTestSuite(options: Partial<TestSuiteOptions> = {}): Promise<void> {
    const defaultOptions: TestSuiteOptions = {
      scope: 'full',
      parallel: true,
      generateData: true,
      runCoverage: true,
      medicalGrade: true,
      costOptimization: true,
      maxConcurrency: 3
    };

    const finalOptions = { ...defaultOptions, ...options };

    logger.info('üè• Starting Medical Triage System Testing Suite', {
      scope: finalOptions.scope,
      parallel: finalOptions.parallel,
      medicalGrade: finalOptions.medicalGrade,
      timestamp: new Date().toISOString()
    });

    try {
      // Run comprehensive test generation
      const results = await this.orchestrator.generateCompleteTestSuite(
        finalOptions.scope,
        {
          parallel: finalOptions.parallel,
          maxConcurrency: finalOptions.maxConcurrency || 3,
          generateData: finalOptions.generateData,
          runCoverage: finalOptions.runCoverage,
          medicalGradeValidation: finalOptions.medicalGrade,
          costOptimization: finalOptions.costOptimization
        }
      );

      // Report results
      this.reportResults(results);

      // Run generated tests if requested
      if (process.argv.includes('--execute')) {
        await this.executeGeneratedTests();
      }

      logger.info('‚úÖ Medical Triage System Testing Suite completed successfully', {
        totalTests: results.totalTests,
        totalCoverage: results.totalCoverage,
        executionTime: results.executionTime,
        recommendations: results.recommendations.length
      });

    } catch (error) {
      logger.error('‚ùå Testing suite failed', { error: error.message });
      process.exit(1);
    }
  }

  private reportResults(results: any): void {
    console.log('\nüìä TESTING SUITE RESULTS');
    console.log('========================');
    console.log(`Total Tests Generated: ${results.totalTests}`);
    console.log(`Overall Coverage: ${results.totalCoverage}%`);
    console.log(`Execution Time: ${(results.executionTime / 1000).toFixed(2)}s`);
    console.log(`Success Rate: ${(results.results.filter((r: any) => r.success).length / results.results.length * 100).toFixed(1)}%`);

    // Results by type
    console.log('\nüìã RESULTS BY TEST TYPE');
    console.log('-----------------------');
    const byType = results.results.reduce((acc: any, result: any) => {
      acc[result.type] = acc[result.type] || { count: 0, tests: 0, success: 0 };
      acc[result.type].count++;
      acc[result.type].tests += result.testCount;
      if (result.success) acc[result.type].success++;
      return acc;
    }, {});

    Object.entries(byType).forEach(([type, stats]: [string, any]) => {
      console.log(`${type.toUpperCase()}: ${stats.success}/${stats.count} successful (${stats.tests} tests)`);
    });

    // Medical-specific metrics
    console.log('\nüè• MEDICAL COMPLIANCE METRICS');
    console.log('-----------------------------');
    const medicalResults = results.results.filter((r: any) => 
      r.target.includes('Agent') || r.target.includes('Orchestrator')
    );
    
    console.log(`Medical Components Tested: ${medicalResults.length}`);
    console.log(`Emergency Scenarios Covered: ${results.results.filter((r: any) => 
      r.filesGenerated.some((f: string) => f.includes('emergency'))
    ).length}`);
    console.log(`Agent Interactions Tested: ${results.results.filter((r: any) => 
      r.type === 'integration' && r.target.includes('agent')
    ).length}`);

    // Recommendations
    if (results.recommendations.length > 0) {
      console.log('\nüìù RECOMMENDATIONS');
      console.log('------------------');
      results.recommendations.forEach((rec: string, index: number) => {
        console.log(`${index + 1}. ${rec}`);
      });
    }

    console.log('\n');
  }

  private async executeGeneratedTests(): Promise<void> {
    logger.info('üèÉ Executing generated tests...');

    try {
      // Run unit tests
      await this.runCommand('pnpm test', 'Unit Tests');
      
      // Run integration tests
      await this.runCommand('pnpm test:integration', 'Integration Tests');
      
      // Run contract tests
      await this.runCommand('pnpm test:contract', 'Contract Tests');
      
      // Run performance tests
      await this.runCommand('pnpm test:performance', 'Performance Tests');

      logger.info('‚úÖ All generated tests executed successfully');

    } catch (error) {
      logger.error('‚ùå Test execution failed', { error: error.message });
      throw error;
    }
  }

  private async runCommand(command: string, description: string): Promise<void> {
    console.log(`\nüîÑ Running ${description}...`);
    
    const { spawn } = require('child_process');
    const [cmd, ...args] = command.split(' ');
    
    return new Promise((resolve, reject) => {
      const process = spawn(cmd, args, { 
        stdio: 'inherit',
        shell: true 
      });
      
      process.on('close', (code: number) => {
        if (code === 0) {
          console.log(`‚úÖ ${description} completed successfully`);
          resolve();
        } else {
          console.log(`‚ùå ${description} failed with code ${code}`);
          reject(new Error(`${description} failed`));
        }
      });
    });
  }

  async generateSpecificTests(targets: string[]): Promise<void> {
    logger.info('Generating tests for specific targets', { targets });

    for (const target of targets) {
      try {
        const request = {
          id: `manual-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: this.inferTestType(target),
          target,
          scope: 'component' as const,
          priority: 'high' as const,
          medicalContext: this.inferMedicalContext(target)
        };

        const result = await this.orchestrator['processTestRequest'](request);
        
        if (result.success) {
          logger.info(`‚úÖ Generated tests for ${target}`, {
            testCount: result.testCount,
            filesGenerated: result.filesGenerated.length
          });
        } else {
          logger.error(`‚ùå Failed to generate tests for ${target}`, {
            error: result.error
          });
        }
      } catch (error) {
        logger.error(`Failed to process target ${target}`, { error: error.message });
      }
    }
  }

  private inferTestType(target: string): 'unit' | 'integration' | 'contract' | 'performance' {
    if (target.includes('api/')) return 'contract';
    if (target.includes('Orchestrator')) return 'integration';
    if (target.includes('performance')) return 'performance';
    return 'unit';
  }

  private inferMedicalContext(target: string) {
    if (target.includes('Agent')) {
      const agentType = target.split('/').pop()?.replace('.ts', '');
      return {
        agentType,
        clinicalScenarios: this.getDefaultClinicalScenarios(agentType),
        riskLevels: ['immediate', 'urgent', 'routine', 'low']
      };
    }
    
    if (target.includes('Orchestrator')) {
      return {
        clinicalScenarios: ['emergency_workflow', 'batch_processing', 'cost_optimization'],
        riskLevels: ['immediate', 'urgent', 'routine', 'batch']
      };
    }

    return undefined;
  }

  private getDefaultClinicalScenarios(agentType?: string): string[] {
    const scenarioMap: Record<string, string[]> = {
      SymptomParserAgent: ['chest_pain_parsing', 'respiratory_symptoms', 'structured_extraction'],
      RiskStratifierAgent: ['immediate_risk_flags', 'urgent_care_scenarios', 'confidence_scoring'],
      CarePathwayPlannerAgent: ['ed_referrals', 'urgent_care_routing', 'safety_netting'],
      EmpathyCoachAgent: ['patient_communication', 'clinician_reports', 'anxiety_management'],
      ConductorAgent: ['workflow_orchestration', 'red_flag_detection', 'agent_coordination']
    };

    return scenarioMap[agentType || ''] || ['general_medical_scenarios'];
  }
}

// CLI Interface
async function main() {
  const runner = new MedicalTriageTestRunner();
  const args = process.argv.slice(2);

  try {
    if (args.includes('--help') || args.includes('-h')) {
      printUsage();
      return;
    }

    const options: Partial<TestSuiteOptions> = {};

    // Parse command line options
    if (args.includes('--scope')) {
      const scopeIndex = args.indexOf('--scope') + 1;
      options.scope = args[scopeIndex] as any;
    }

    if (args.includes('--no-parallel')) {
      options.parallel = false;
    }

    if (args.includes('--no-data')) {
      options.generateData = false;
    }

    if (args.includes('--no-coverage')) {
      options.runCoverage = false;
    }

    if (args.includes('--concurrency')) {
      const concurrencyIndex = args.indexOf('--concurrency') + 1;
      options.maxConcurrency = parseInt(args[concurrencyIndex]);
    }

    // Handle specific commands
    if (args.includes('--targets')) {
      const targetsIndex = args.indexOf('--targets') + 1;
      const targets = args[targetsIndex].split(',');
      await runner.generateSpecificTests(targets);
    } else {
      await runner.runFullTestSuite(options);
    }

  } catch (error) {
    console.error('‚ùå Testing suite execution failed:', error.message);
    process.exit(1);
  }
}

function printUsage() {
  console.log(`
üè• Medical Triage System - Comprehensive Testing Suite

Usage: pnpm run test:generate [options]

Options:
  --scope <scope>      Test scope: agents, adapters, orchestrator, full (default: full)
  --targets <list>     Comma-separated list of specific targets to test
  --concurrency <n>    Maximum concurrent test generations (default: 3)
  --no-parallel       Disable parallel test execution
  --no-data           Skip test data generation
  --no-coverage       Skip coverage analysis
  --execute           Execute generated tests after generation
  --help, -h          Show this help message

Examples:
  pnpm run test:generate                                    # Full test suite
  pnpm run test:generate --scope agents                     # Test only agents
  pnpm run test:generate --targets "AnthropicProvider,BatchProcessor"
  pnpm run test:generate --execute --concurrency 5          # Generate and run tests

Medical Testing Standards:
- Critical components require 95%+ coverage
- Emergency scenarios must have 100% coverage
- All agent interactions require integration testing
- Performance testing required for medical-grade systems
`);
}

// Execute if run directly
if (require.main === module) {
  main();
}

export { MedicalTriageTestRunner };