// Generated unit tests for AnthropicProvider
// Auto-generated by UnitTestGenerator - Medical Triage System
// Target: lib/adapters/llm/AnthropicProvider
// Generated: ${new Date().toISOString()}

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { faker } from '@faker-js/faker';
import { AnthropicProvider } from '@/lib/adapters/llm/AnthropicProvider';
import { Anthropic } from '@anthropic-ai/sdk';

const mockLlmProvider = vi.fn();
const mockLogger = { info: vi.fn(), error: vi.fn(), warn: vi.fn(), debug: vi.fn() };

// Mock the Anthropic SDK
vi.mock('@anthropic-ai/sdk', () => ({
  Anthropic: vi.fn().mockImplementation(() => ({
    messages: {
      create: vi.fn(),
      batches: {
        create: vi.fn(),
        retrieve: vi.fn()
      }
    }
  }))
}));

describe('AnthropicProvider', () => {
  beforeEach(() => { vi.clearAllMocks(); });
  afterEach(() => { vi.restoreAllMocks(); });

  describe('happy-path', () => {
    it('should initialize with default configuration successfully', async () => {
      // Arrange
      const provider = new AnthropicProvider('test-api-key');
      
      // Assert
      expect(provider).toBeDefined();
      expect(Anthropic).toHaveBeenCalledWith({ apiKey: 'test-api-key' });
    });

    it('should process medical triage chat request successfully', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: '{"symptoms": "chest pain", "severity": 8}' }],
        usage: { input_tokens: 150, output_tokens: 50 }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      const messages = [
        { role: 'system' as const, content: 'You are a medical triage assistant' },
        { role: 'user' as const, content: 'I have severe chest pain radiating to my left arm' }
      ];
      
      // Act
      const result = await provider.chat(messages, { temperature: 0.1 });
      
      // Assert
      expect(result).toBe('{"symptoms": "chest pain", "severity": 8}');
      expect(mockClient.messages.create).toHaveBeenCalledTimes(1);
    });

    it('should handle prompt caching for system prompts', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: 'Cached system prompt response' }],
        usage: { 
          input_tokens: 100, 
          output_tokens: 30,
          cache_creation_input_tokens: 80,
          cache_read_input_tokens: 20
        }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key', 'claude-3-5-haiku-20241022', true);
      const systemPrompt = 'You are a medical triage system. This is a long system prompt that should be cached for cost optimization.';
      
      // Act
      await provider.chat([
        { role: 'system', content: systemPrompt },
        { role: 'user', content: 'chest pain' }
      ], { enableCaching: true });
      
      // Assert
      expect(mockClient.messages.create).toHaveBeenCalledWith(
        expect.objectContaining({
          model: 'claude-3-5-haiku-20241022',
          system: expect.arrayContaining([
            expect.objectContaining({
              type: 'text',
              text: systemPrompt,
              cache_control: { type: 'ephemeral' }
            })
          ])
        })
      );
    });

    it('should route to appropriate model based on complexity', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: 'Complex medical reasoning response' }],
        usage: { input_tokens: 200, output_tokens: 100 }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider(
        'test-api-key', 
        'claude-3-5-haiku-20241022', 
        true, 
        'claude-3-5-sonnet-20241022', 
        true
      );
      
      // Complex medical scenario that should trigger Sonnet
      const complexMedicalScenario = [
        { role: 'system' as const, content: 'Perform differential diagnosis analysis' },
        { role: 'user' as const, content: 'Patient presents with complex medical reasoning required for differential diagnosis of chest pain with multiple comorbidities and drug interactions' }
      ];
      
      // Act
      await provider.chat(complexMedicalScenario);
      
      // Assert
      expect(mockClient.messages.create).toHaveBeenCalledWith(
        expect.objectContaining({
          model: 'claude-3-5-sonnet-20241022' // Should route to Sonnet for complex case
        })
      );
    });
  });

  describe('edge-case', () => {
    it('should handle empty message array', async () => {
      // Arrange
      const provider = new AnthropicProvider('test-api-key');
      
      // Act & Assert
      await expect(provider.chat([])).rejects.toThrow();
    });

    it('should handle very long medical input gracefully', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: 'Processed long medical input' }],
        usage: { input_tokens: 5000, output_tokens: 200 }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      const longMedicalHistory = faker.lorem.paragraphs(50); // Very long input
      
      // Act
      const result = await provider.chat([
        { role: 'user', content: `Medical history: ${longMedicalHistory}` }
      ]);
      
      // Assert
      expect(result).toBe('Processed long medical input');
      expect(mockClient.messages.create).toHaveBeenCalledTimes(1);
    });

    it('should handle special characters in medical terminology', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: 'Processed special characters' }],
        usage: { input_tokens: 100, output_tokens: 30 }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      const specialCharInput = 'Patient has α-blocker medication, β-receptor issues, & respiratory rate >30/min';
      
      // Act
      const result = await provider.chat([
        { role: 'user', content: specialCharInput }
      ]);
      
      // Assert
      expect(result).toBe('Processed special characters');
      expect(mockClient.messages.create).toHaveBeenCalledTimes(1);
    });
  });

  describe('error-handling', () => {
    it('should handle network timeout errors gracefully', async () => {
      // Arrange
      const mockClient = {
        messages: { create: vi.fn().mockRejectedValue(new Error('Network timeout')) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      
      // Act & Assert
      await expect(provider.chat([
        { role: 'user', content: 'Emergency chest pain' }
      ])).rejects.toThrow('Anthropic API call failed: Network timeout');
    });

    it('should handle API rate limiting errors', async () => {
      // Arrange
      const mockClient = {
        messages: { create: vi.fn().mockRejectedValue(new Error('Rate limit exceeded')) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      
      // Act & Assert
      await expect(provider.chat([
        { role: 'user', content: 'Medical query' }
      ])).rejects.toThrow('Anthropic API call failed: Rate limit exceeded');
    });

    it('should handle invalid API response format', async () => {
      // Arrange
      const mockResponse = {
        content: [], // Empty content array
        usage: { input_tokens: 50, output_tokens: 0 }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      
      // Act
      const result = await provider.chat([
        { role: 'user', content: 'Test message' }
      ]);
      
      // Assert
      expect(result).toBe(''); // Should return empty string for invalid response
    });

    it('should handle malformed JSON in API response', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: 'Invalid JSON: {malformed' }],
        usage: { input_tokens: 50, output_tokens: 20 }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      
      // Act
      const result = await provider.chat([
        { role: 'user', content: 'Medical query' }
      ]);
      
      // Assert
      expect(result).toBe('Invalid JSON: {malformed'); // Should return raw text if not parseable
    });
  });

  describe('medical-scenario', () => {
    it('should process emergency chest pain scenario with high priority', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: '{"riskLevel": "immediate", "disposition": "ED", "redFlags": ["chest pain with radiation"]}' }],
        usage: { input_tokens: 200, output_tokens: 80 }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      const emergencyScenario = [
        { role: 'system' as const, content: 'You are a medical triage system focused on emergency detection' },
        { role: 'user' as const, content: 'Severe crushing chest pain for 45 minutes, radiating to left arm, with nausea and diaphoresis. Patient is diaphoretic and appears distressed.' }
      ];
      
      // Act
      const result = await provider.chat(emergencyScenario, { temperature: 0.1 });
      
      // Assert
      expect(result).toContain('immediate');
      expect(result).toContain('ED');
      expect(mockClient.messages.create).toHaveBeenCalledWith(
        expect.objectContaining({
          temperature: 0.1,
          model: expect.any(String)
        })
      );
    }, {
      medicalContext: {
        scenario: 'emergency_chest_pain',
        riskLevel: 'immediate',
        expectedBehavior: 'immediate_ed_referral'
      }
    });

    it('should handle routine care scenario with cost optimization', async () => {
      // Arrange
      const mockResponse = {
        content: [{ type: 'text', text: '{"riskLevel": "routine", "disposition": "Primary Care", "timeframe": "48-72 hours"}' }],
        usage: { 
          input_tokens: 120, 
          output_tokens: 40,
          cache_read_input_tokens: 80 // Cached prompt usage
        }
      };
      
      const mockClient = {
        messages: { create: vi.fn().mockResolvedValue(mockResponse) }
      };
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const provider = new AnthropicProvider('test-api-key');
      const routineScenario = [
        { role: 'system' as const, content: 'You are processing routine medical concerns for cost-effective care routing' },
        { role: 'user' as const, content: 'Mild headache for 2 days, no red flags, managing with over-the-counter medications' }
      ];
      
      // Act
      const result = await provider.chat(routineScenario, { enableCaching: true });
      
      // Assert
      expect(result).toContain('routine');
      expect(result).toContain('Primary Care');
      expect(mockClient.messages.create).toHaveBeenCalledTimes(1);
    }, {
      medicalContext: {
        scenario: 'routine_care',
        riskLevel: 'routine',
        expectedBehavior: 'primary_care_routing'
      }
    });

    it('should estimate cache savings for repeated medical queries', () => {
      // Arrange
      const provider = new AnthropicProvider('test-api-key', 'claude-3-5-haiku-20241022', true);
      const messages = [
        { role: 'system', content: 'You are a medical triage system. This long prompt contains clinical guidelines and should be cached for repeated use across multiple patient assessments.' },
        { role: 'user', content: 'Patient presents with chest pain' }
      ];
      
      // Act
      const savings = provider.estimateCacheSavings(messages);
      
      // Assert
      expect(savings.cacheableTokens).toBeGreaterThan(0);
      expect(savings.potentialSavings).toBeGreaterThan(0);
      expect(savings.potentialSavings).toBeLessThanOrEqual(savings.cacheableTokens);
    });

    it('should create agent-optimized provider for RiskStratifier', () => {
      // Arrange
      const provider = new AnthropicProvider('test-api-key');
      
      // Act
      const agentProvider = provider.createAgentOptimizedProvider('RiskStratifierAgent');
      
      // Assert
      expect(agentProvider).toBeDefined();
      expect(agentProvider).toBeInstanceOf(AnthropicProvider);
    });

    it('should handle batch processing for routine triage requests', async () => {
      // Arrange
      const mockBatchJob = {
        id: 'batch-123',
        processing_status: 'completed',
        archive_url: 'https://example.com/batch-results.jsonl'
      };
      
      const mockBatchResults = `{"custom_id": "req-1", "result": {"content": [{"type": "text", "text": "batch result 1"}]}}
{"custom_id": "req-2", "result": {"content": [{"type": "text", "text": "batch result 2"}]}}`;
      
      const mockClient = {
        messages: {
          batches: {
            create: vi.fn().mockResolvedValue(mockBatchJob),
            retrieve: vi.fn().mockResolvedValue(mockBatchJob)
          }
        }
      };
      
      // Mock fetch for batch results
      global.fetch = vi.fn().mockResolvedValue({
        text: vi.fn().mockResolvedValue(mockBatchResults)
      });
      
      vi.mocked(Anthropic).mockImplementation(() => mockClient as any);
      
      const batchOptions = {
        enableBatching: true,
        batchSize: 10,
        maxWaitTimeMs: 5000,
        batchingThreshold: 2
      };
      
      const provider = new AnthropicProvider(
        'test-api-key', 
        'claude-3-5-haiku-20241022',
        true,
        'claude-3-5-sonnet-20241022',
        true,
        batchOptions
      );
      
      // Act & Assert
      expect(provider.getBatchStats()).toBeDefined();
      
      // Test batch flushing
      await provider.flushBatch();
      expect(provider.getBatchStats()?.pendingRequests).toBe(0);
    }, {
      medicalContext: {
        scenario: 'batch_processing',
        riskLevel: 'routine',
        expectedBehavior: 'cost_optimized_batching'
      }
    });
  });
});